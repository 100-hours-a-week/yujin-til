## 📆 2025-09-29

### 🔔 스크럼

- Spring boot 기본 강의 복습 및 정리
- 과제 기본 구성
  - 커뮤니티 폴더구조
  - 깃헙 구조

### 🚀 Today I Learned

#### Spring

- 자바 언어 기반의 framework - 객체생성, 의존성 관리를 자동화해 구조를 단순하고 유연하게 만듬
- 자바 = 객체지향 언어
  - 특징 : 캡슐화, 상속, 추상화, 다형성
  - SOLID 원칙
    - S : SRP (Single Responsibility Principle, 단일 책임 원칙)→ 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행
    - O : OCP(Open Closed Principle, 개방 폐쇄 원칙) → 클래스를 확장을 통해 손쉽게 수현하면서, 확장에 따른 클래스 수정은 최소화
      - 어려울것 없이 자바의 추상클래스, 상속을 통한 클래스 관계임
    - L : LSP(Liskov Substitution Principle, 리스코프 치환원칙) → 서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야함
      - 다형성 원리를 이용하기 위한 원칙
    - I : ISP(Interface Secregation Principle, 인터페이스 분리 원칙) → 인터페이스를 각각 사용에 맞게끔 잘게 분리
    - D : DIP(Dependency Inversion Principle, 의존 역전 원칙) → 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- Why? 객체 관리와 설정을 자동화하여 개발 생산성과 유지보수성을 높이고, 대규모 시스템에서도 안정적이고 확장 가능한 애플리케이션을 만들 수 있기 때문
- 특징
  1. IoC(제어역전) : 객체 생성과 생명 주기 관리를 개발자가 아닌 프레임워크가 하는 방식
  2. DI(의존성 주입) : 객체가 필요로 하는 의존성을 외부(컨테이너)에서 주입시키는 것
     - IoC, DI는 같이 나오는 개념
     - new로 선언하는 대신 프레임워크가 관리해주는것
     - DI 방법 : 필드주입, 생성자 주입(가장 많이 사용), 세터주입
  3. 경량 & 유연성 : 무거운 컨테이너가 아니라 순수자바로 개발가능, 필요한 모듈 선택적 사용가능
  4. AOP : 관점 지향 프로그래밍이라는 뜻으로, 공통,반복적으로 등장하는 기능을 핵심기능과 분리하여 별도로 관리할 수 있게 해주는 개념
  5. Test용이성 : 객체가 컨테이너에 관리됨으로 쉬워진 test ex) JUnit, TestNG
- Annotation(@) : 자바 코드에 메타데이터를 추가해, 컴파일러나 런타임에 특정 동작을 지시하거나 정보를 제공하는 표기방법
  - 만약 오버라이드로 함수를 쓴건데, @override안쓰면 오타가 나도 인지하지 못하고 넘어감
- Spring 컨테이너
  - 빈들(객체)을 생성,관리,주입하는 IoC/DI 엔진, 애플리케이션 실행환경을 감사는 껍데기 ⇒ Spring 프레임워크가 객체(Bean)를 관리하는 공간
  - 동작방식
    1. 빈 스캐닝 + 등록 : @component,service 등을 찾아서 빈으로 등록
    2. 빈 생성 + 의존성 주입 : 필요한 객체를 new하고, 생성자,필드,세터 주입
    3. 라이프 사이클 관리 : 초기화, 종료
    4. 환경설정 관리 : 프로파일, 프로퍼티 설정
    5. 이벤트 발행 : 내부 이벤트를 다른 빈에게 전달
- Spring MVC : 스프링 프레임워크에서 제공하는 웹 애플리케이션 개발을 위한 아키텍처, Model(데이터, 비즈니스 로직)- view(사용자화면)-Controller(요청처리, 모델-뷰 연결)패턴 기반
- Spring Bean : 스프링 컨테이너가 직접 생성, 관리까지 책임지는 객체
  - 싱글톤 패턴임 : 하나의 클래스에서 객체를 단 하나만 만들어 애플리케이션 전체에서 함께 쓰는 방식
    - new로 선언하면 다 다른 객체가 생성됨. 근데 spring은 알아서 생성해서 관리해주니까 싱글톤 패턴으로 객체가 생성됨
  - 등록 방법 : 컴포넌트 스캐닝(자동 등록, 7-80%), 수동 등록(@Bean)
- 동작 방식
  <img width="519" height="453" alt="Image" src="https://github.com/user-attachments/assets/dd80c1d3-99de-4d04-b193-16ea1652862b" />
  - Core Container : 스프링 엔진 역할, 모든 객체 관리와 설정의 중심
    - Beans : spring이 대신 관리해주는 객체
    - Core : spring의 뼈대 역할, **객체를 생성하고 주입해주는 IoC/DI 기능이 여기서 제공**
  - AOP 영역(AOP, Aspects) : 공통,반복적으로 등장하는 기능을 핵심기능과 분리하여 별도로 관리할 수 있게 해주는 개념
  - Instrumentation & Messaging : 애플리케이션 동작감시, 시스템간 msg를 주고받는 기능 담당(로깅, 성능분석)
  - Data Access / Integration : DB나 메시지시스템 등 외부자원과 어플리케이션을 연결
  - Web (MVC / Remoting) : 웹구조로부터 최신 신시간 통신 지원, API서버와 대규모 통신 서비스 구축에 필수적 역할

#### Spring Boot

- 스프링 애플리케이션을 빠르고 쉽게 개발할 수 있도록 설정과 배포를 자동화한 프레임워크
- 제공 기능
  - 자동 설정 : classpath에 어떤 라이브러리가 있는지를 확인하고, 거기에 맞는 설정을 자동으로 적용
  - Starter 의존성 관리 : Starter라는 의존성 패키지 모음
  - 내장 서버 : Tomcat(또는 Jetty 등)을 **내장 서버 형태로 포함**하기 때문에, 별도의 서버 설치 없이 애플리케이션을 바로 실행

#### ORM(Object Relational Mapping)

- 자바의 객체와 DB 테이블을 자동으로 연결하고 반환해, 객체 지향 코드로 데이터를 조작할 수 있게 해주는 기술 ⇒ DB를 객체지향적으로 활용할 수 있음
- Why? 객체지향과 RDB간의 간극을 줄여, 설계의 일관성과 코드의 생산성을 높이기 위해 사용

#### JPA(Java Persistence API)

- 자바 객체와 RDB를 매핑하고, 객체 단위로 데이터를 저장/조회 할수 있게 해주는 표준 ORM인터페이스
- 엔티티 객체를 JPA에게 전달하면, JPA는 객체 구조를 분석해 필요한 `INSERT`, `UPDATE`, `SELECT` SQL을 자동으로 생성하고, JDBC를 통해 실행까지 처리함

#### Entity

- DB 테이블과 1:1로 매핑하여 데이터를 객체화하는 자바 클래스
- `@Entity` 붙으면 JPA가 관리하는 엔티티로 인식
- Why? 데이터를 하나의 객체로 묶어 구조와 규칙을 함께 관리하여 코드의 오류를 줄이고 설계를 일관되게 유지할 수 있기 때문

#### DTO(Data Transfer Object)

- 계층 간 데이터 전달을 위해 사용하는, 값만 담는 전용 객체
- Why? 엔티티의 내부 구조나 민감 정보를 외부에 노출하지 않고, 필요한 데이터만 안전하고 명확하게 전달하기 위해 사용됨
- 실무에서는 엔티티를 직접 반환하기보다, **필요한 데이터만 담은 DTO로 변환해 반환**하는 것이 훨씬 안전하고 명확한 방법

#### 기본키 생성 전략

- 엔티티의 ID 값을 자동으로 만들기 위해 숫자를 직접 넣을지, DB 시퀀스를 사용할지, 자동 증가 컬럼을 쓸지 등을 지정하는 방식

1. **TABLE 전략** : 별도의 키 전용 테이블을 두고 시퀀스 동작을 흉내 내는 방식 → 실무에서는 다른전력을 우선으로 생각함

   ```java
   @Entity
   @TableGenerator(
       name = "user_gen",
       table = "id_generator",
       pkColumnName = "entity_name",
       valueColumnName = "next_id",
       pkColumnValue = "user",
       allocationSize = 1
   )
   public class User {

       @Id
       @GeneratedValue(strategy = GenerationType.TABLE, generator = "user_gen")
       private Long id;

       private String email;
   }
   ```

2. **SEQUENCE 전략 :** 데이터베이스에 존재하는 시퀀스 오브젝트를 이용해 기본 키 값을 생성하는 방식

   - ex ) Oracle, PostgreSQL 등 일부 데이터베이스에서 지원
   - INSERT 실행 전 이미 키 값을 확보할 수 있다는 특징→ 쓰기 지연이나 배치 처리 같은 기능과 잘 어울림

   ```java
   @Entity
   @SequenceGenerator(
       name = "post_seq",
       sequenceName = "post_seq",
       allocationSize = 50 // 여러개의 키를 한번에 미리 가져와 메모리에 저장
   )
   public class Post {
       @Id
       @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "post_seq")
       private Long id;
       private String title;
   }
   ```

3. **IDENTIFY 전략 :** 데이터베이스의 자동 증가 컬럼을 사용하여 기본 키를 생성

   - ex ) MySQL의 AUTO_INCREMENT
   - 키 값을 알기 위해 즉시 INSERT를 수행 →쓰기 지연(batch insert) 최적화에는 제약O

   ```java
   @Entity
   public class User {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String email;
   }
   ```

4. **AUTO 전략** : PA가 데이터베이스 방언을 기준으로 적절한 키 생성 방식을 자동 매핑해 주는 방법
   - ex ) mysql - `AUTO_INCREMENT`, Oracle - 시퀀스

<aside>
💡 IDENTIFY vs AUTO <br>
MySQL 환경에서는 AUTO 전략과 IDENTITY 전략이 동일하게 동작(AUTO_INCREMENT)하지만, 다른 DB로 변경하면 동작 방식이 달라짐
</aside>

### 🔥 오늘의 도전 과제와 해결 방법

- spring boot jdk 버전 충돌 오류
  - 원인 : 에러 로그를 확인해보니 java toolchain이 JDK 21을 요구하는데, 내 로컬 환경에는 JDK 24만 설치되어 있어서 Gradle이 필요한 JDK 버전을 찾지 못하는 것이 원인
  - 해결방법 : Homebrew 설치 후 JDK 21 설치 → JAVA_HOME 및 PATH 적용 → IntelliJ에서 Gradle JVM 및 Project SDK를 JDK 21로 변경 → Gradle 리프레시 후 실행 성공

### 🗨️ 오늘의 회고

- 월요일마다 강의와 과제가 몰려서 항상 정신이 없고, 시작도 전에 괜히 겁부터 먹는 느낌이 있었다.
  오늘도 JDK 버전 충돌 때문에 스프링부트 프로젝트가 제대로 실행되지 않아 처음엔 당황했지만,
  에러 로그를 차근히 분석하고 하나씩 해결해보면서 “내가 뭘 해야 하는지 정확히 알고 움직이는 것”이 얼마나 중요한지 다시 느꼈다.
- 평소처럼 막연하게 불안해하기보다, TODO 리스트를 더 세세하게 나누고 할 일을 명확히 정리하니 생각보다 훨씬 수월하게 해결할 수 있었다.
- 이번 주부터 스프링부트를 본격적으로 다루고 개인 프로젝트도 계속 이어지는데, 하나씩 문제를 해결해가며 프레임워크와 더 친해지는 시간이 될 것 같다.
