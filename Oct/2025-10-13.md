## 📆 2025-10-13

### 🔔 스크럼

- 웹 기초/응용 강의 복습 및 정리
- 이번주차 과제 2번 기초 구성 70%
  - 폴더 구성 완료
  - 퍼블리시 80%
  - 프론트 필요한 기능들 나열

### 🚀 Today I Learned

#### HTML

- 하이퍼텍스트를 처리하기 위해 만들어진 언어 → 웹페이지의 구조와 내용을 정의하기 위한 언어
- 시멘틱 태그 : 웹페이지에 내용을 표시하는 것뿐 아니라 어떤 의미를 가지는지를 나타내는 태그 → 코드 구조 명확, 가독성 up , 유지보수 Good, 검색 엔진 최적화(SEO)에 도움됨
  - ex) `<header>`, `<footer>`, `<article>`, `<section>`

#### CSS

- HTML에 입힐 스타일(글씨 색깔, 배경색 등)을 저장해둔 스타일 시트
- 요소 선택자, 클래스 선택자(.class), ID 선택자(#id)
- 경로 → 서버에서 HTML 파일을 로드할 때 CSS 파일이 제대로 로딩되지 않는 문제는 주로 경로 설정 오류에서 발생
  - 절대 경로 : 루트 di부터 정확하게 지정하는 경로
  - 상대 경로 : 현재 파일의 위치 기준으로하는 상대적인 경로

#### JS

- 웹페이지를 동적이게 하기 위해 만들어진 프로그래밍 언어

#### HTTP Cache

- 웹 페이지, 이미지, 기타 미디어 파일 등 웹 리소스들을 사용자의 브라우저나 서버에 임시로 저장해두는 기술

- HTTP Cache가 클라이언트에 가까이 붙어있다면, 웹 브라우저(유저 단독)을 위한 것이라고 생각하면 되고, 서버에 가까이 붙어있다면, 서버로 요청을 보내는 모든 웹 브라우저(유저 다수)를 위한 것
- 캐시 제어 방법 : `Cache-Control`, `Expires`, `ETag` 등

#### HTTP ETag

- Entity Tag로, 서버-클라이언트 간의 캐시가 최신인지를 확인하기 위해 사용되는 태그

#### 폴링과 롱폴링

- 서버-클라이언트 간의 실시간 통신구현을 위해 사용되는 기법
- 폴링 : 클라이언트가 주기마다 서버 데이터가 업데이트 되었는지 요청을 보내는 방식
  - ex) 온라인 시험 중 남은 시간 표시
  - Why? HTTP의 한계를 넘어 유저에게 실시간 통신을 하는 것처럼 보여주기 위해서
- 롤폴링 : 클라이언트가 서버에 요청을 보내고, 서버는 새로운 데이터가 준비될때까지 응답을 지연시키는 방식
  - ex) 스포츠 경기 실시간 점수 업데이트 - 새로운 점수, 이벤트 발생시 즉시 업뎃

#### WebSocket

- 실시간 양방향 통신을 위해 신뢰성 있는 지속적 연결을 할수있게 하는 프로토콜
- 한 번의 연결 설정 후 지속적으로 데이터를 교환할 수 있어 네트워크 부하와 지연 시간을 줄일 수 있음

#### WS, WAS

- Web Server : HTTP를 통해 클라이언트의 요청에 주로 **정적페이지**를 응답
- Web Application Server : **동적인** 웹페이지와 어플리케이션 서비스를 제공하는 서버 소프트웨어
- 일반적으로 작은 서비스에서는 둘 중 하나만 사용해도 충분 → But, 커지면 두개 동시사용함

- CGI(Common Gateway Interface)
  | **특성** | **설명** |
  | ------------- | ---------------------------------------------------------------------------------- |
  | **정의** | 웹 서버와 외부 스크립트 또는 프로그램 사이의 인터페이스 표준입니다. |
  | **필요성** | 웹 서버가 동적 콘텐츠를 생성하여 사용자 요청에 실시간으로 반응할 수 있게 해줍니다. |
  | **연결 방식** | 요청마다 새로운 프로세스를 생성하여 스크립트를 실행하고 결과를 반환합니다. |

#### Apache vs Nginx

- 웹 서버 소프트웨어
- Apache : 클라이언트로부터 HTTP 요청을 받으면, 서버의 설정 파일과 설치된 모듈을 확인하여 해당 요청을 처리
  - 클라이언트 요청 당 하나의 스레드가 처리하는 구조 → 용자가 많으면 스레드 생성, 메모리 및 CPU 낭비가 심함
  - 동적 콘텐츠를 처리하기 위한 다양한 모듈(PHP, Perl, Python 등)을 내장하고 있어, 직접적으로 동적 콘텐츠를 처리가능
- Nginx : 클라이언트로부터의 요청을 받아, 이를 기반으로 정적 파일을 제공하거나 프록시 서버로서 다른 서버에 요청을 전달
  - Event-Driven 처리 구조
  - 비동기 이벤트 기반의 처리 모델을 사용하여, 소수의 스레드로 많은 수의 연결을 효율적으로 처리할 수 있음

#### Event Driven

- 해석하자면 “이벤트 중심”
- 발생하는 이벤트에 맞게 자동으로 반응하여 처리하는 방식
- EDA(Event Driven Architecture) : MSA(Micro Service Architecture)를 보완하기 위해 나온 방식으로 “분산된 시스템에서 **이벤트**를 생성(발행)하고 발행된 이벤트를 수신자에게 전송하는 구조로 수신자는 그 이벤트를 처리하는 방식의 아키텍쳐”

#### 자바스크립트 엔진

- 자바스크립트 코드를 실행하는 인터프리터
- 웹 브라우저나 Node.js와 같은 런타임 환경에서 사용 - 비동기 작업 지원
- ex ) 구글 크롬의 V8 엔진

#### 브라우저의 동작 방식

- HTML안에 css,js 중 어떤걸 호출할것인지에 따라 랜더링 시간차이가 발생함
  - 보통 `<head>`에 css → `<body>`에 js

#### DOM

- HTML 코드가 브라우저에 의해 파싱되어 메모리 상에 객체의 형태로 구성되고 동작하고 있는 코드
- 브라우저가 HTML을 로드하고 해석하는 과정이고, 웹 페이지를 통적으로 조작하기 위해서
- js로 조작가능 - **`document.querySelector()`, `innerHTML` 등**
  - DOM Tree를 보면 노드상태일때는 우리가 조작X, DOM이기 때문에 조작할수있는것임

#### CSSOM

- 웹 브라우저가 css의 구조와 스타일을 조작하기 위해 사용하는 객체 모델
- js로 조작가능 - **`document.styleSheets`**
- DOM + CSSDOM ⇒ 렌더 트리 만들어서 화면에 뿌려짐

#### `<script>`

- HTML안에 js파일을 포함시키기 위해 쓰는 태그
- 속성
  - async : 비동기 로드 → HTML파싱을 방해하지 X
  - defer : HTML 파싱이 완전히 끝난 후에 실행, `<haed>`에 있을때 유리함

#### Event

- 사용자가 웹 페이지에서 하는 행동들 ex) 클릭, 입력 등
- 이벤트 리스너(**`addEventListener`**) - 특정이벤트 발생시
- 이벤트 핸들러 - 이벤트 리스너에 의해 감지되면 실행되는 코드

#### Fetch

- 컴퓨터가 작업을 실행하기 위해 필요한 정보를 찾아 실행하는 첫단계
- ex ) fetch('https://example.com/data').then(response => response.json())

#### SSR, CSR, ISR, SSG

- 웹 페이지 렌더링의 종류
  - 웹 서버로부터 받은 데이터와 자원을 사용하여 사용자의 웹 브라우저 상에서 시각적으로 표현하는 과정
- **SSR**(Server-Side-Rendering) : 서버에서 모든 데이터를 만들어서 클라이언트한테 전송하는 방식 → 즉, 서버에서 요청이 올때마다 HTML 생성하여 전송
  - 동적인 데이터 처리와 SEO에 유리한 서버 사이드 렌더링 방식
  - ex) php, Spring Thymeleaf, Next.js
- **CSR**(Client-Side-Rendering) : 초기 한번만 서버가 전체 페이지 렌더링 후에는 js가 동작하며 필요한 데이터만 주고받으며 랜더링하는 방식
  - ex) Reat.js
- **ISR**(Incremental Static Regeneration) : 런타임 중에 정적 페이지를 만들거나 업데이트 수 있도록 해주는 SSG과 SSR의 하이브리드 솔루션
  - Next.js 프레임워크에서 도입한 렌더링 방식
- **SSG**(Static-Site-Generation) : 텍스트 입력 파일을 사용해 정적 웹페이지를 생성하여 저장해놓고, 요청하면 바로 제공해주는 방식
  - 빠른 로딩 속도, 높은 캐시 효율성, 호스팅 및 유지보수의 용이성
  - ex) Jekyll, Hugo, Gatsby Next.js

### 🔥 오늘의 도전 과제와 해결 방법

- 프론트 폴더 구상을 고민하다가 아래와 같이 일단 진행했다.
- assets : 프로필 기본이미지와 같은 이미지들, 아이콘 등
- layout : html의 공통적인 껍데기
- middlewares : 요청과 응답 사이에 검사가 필요한 공통로직들
- public : 공통껍데기 안쪽에서 사용자에게 보여지는 파일들
  - component : 각 페이지들의 요소들
  - css
  - js
- routes : 서버 통신을 위한 js들 모음
  - index : page.js, api.js를 합치는 라우팅 허브
  - pages : layout.html로 공통 껍데기를 화면에 랜더링하고 페이지 라우팅하는 파일
  - api : 백엔드 통신을 위해 프록시 서버 역할
- app.js

### 🗨️ 오늘의 회고

- 시작이 제일 어려운 것 같다. 프론트 폴더 구성은 어떻게 하고, 어디서 부터 시작해야할까가 항상 고민인 것 같다.
