## 📆 2025-10-01

### 🔔 스크럼

- 레이어드 아키텍쳐, 값타입과 임베디드 매핑 강의 복습 및 정리
- 이번주 과제 사전작업 진행 : 커뮤니티 백엔드 구현하기
  - 백엔드, 프론트 폴더구조
  - 환경변수 처리 등

### 🚀 Today I Learned

#### API 서버 설계법

##### 레이어드 아키텍쳐

![image.png](../img/LayeredArchitecture.png)

- Controller : 클라이언트 요청/응답 담당
- Service : 비즈니스 로직 담당
- Repository : DB 접근 담당
  - DB(관계지향) vs 객체지향 구조 차이 떄문에, RDB테이블 구조와 규칙을 객체화 해야함 ⇒ **Entity로 RDB 객체화**(테이블, 키 정의, 컨펌매핑)
- DTO(전달한 데이터 구조정의) : 계층간 정보전달을 할때 레이별로 데이터 다르니 사용하는 것.
- 해당 구조는 일반적일것일뿐, 정답을 없음! 핵심은 **관심사 별로 분리!**
  - Why? 관심사 분리로써 중복코드를 피하고 효율적인 개발을 위해!

##### 추가 관심사 분리 + 패턴

- 헬퍼/매퍼 클래스
  - 레포지토리에서 조회한 데이터를 매번 DTO로 변환해야하는데 어디서 해야할까?
  - Entity To Dto로 분리하자! ex)UserMapper/ UserHelper
- 미들웨어(필터, 인터셉트)
  - 클라이언트가 보낸 Data가 잘 왔나? 매번 컨트롤러가 확인해야할까?
  - 말그대로, 요청Data가 오면 Controller 가기전에 인터셉트해서 확인
  - 방법
    1. 컴포넌트형 인터셉트
    2. 요청 DTO에 @valid

       ```java
       public class SignupRequest {
           @NotBlank(message = "이메일은 필수 입력값입니다.")
           @Email(message = "이메일 형식이 올바르지 않습니다.")
           private String email;

           @NotBlank(message = "비밀번호는 필수 입력값입니다.")
           private String password;
       }
       ```

#### 값타입

- 엔티티가 아닌, **단순히 엔티티에 소속된 값**을 표현

1. 기본값
   - 단일 값(예: 이름, 나이, 금액)으로만 의미를 가지는 데이터를 엔티티의 필드로 직접 정의해 테이블 컬럼에 저장하는 방식
   - ex ) 이름(`String`), 나이(`int`), 금액(`long`)
   - JPA에서는 기본값 타입이 3가지임 - 자바 기본형(`int`, `long`, `double` ), 래퍼 클래스(`Integer`, `Long`, `Double`), 문자열(`String`)
     - Entity에서 변수들 선언할때 래퍼 클래스 사용 - 객체로서 null값 허용, 제네릭에서 사용가능
2. 임베디드 타입

   - 두 개 이상의 값을 하나의 객체로 묶어 엔티티에 포함시켜 사용하는, 재사용 가능한 값 타입

   ```java
   // 값 타입 정의
   @Embeddable
   public class ProfileInfo {

       private String imageUrl;
       private String introduction;

       protected ProfileInfo() {} // JPA 기본 생성자
       public ProfileInfo(String imageUrl, String introduction) {
           this.imageUrl = imageUrl;
           this.introduction = introduction;
       }
   }

   // 엔티티에서 사용
   @Entity
   public class User {

       @Id @GeneratedValue
       private Long id;
       private String username;

       @Embedded
       private ProfileInfo profileInfo; // 임베디드 타입 사용

       protected User() {}
       public User(String username, ProfileInfo profileInfo) {
           this.username = username;
           this.profileInfo = profileInfo;
       }
   }
   ```

3. 컬렉션

   - 엔티티에 직접 연관되지 않는 여러 개의 값(예: 태그 목록, 주소 이력 등)을 리스트나 세트 형태로 저장하기 위한 값 타입

   ```java
   @Embeddable
   public class Tag {
       private String name;

       protected Tag() {}
       public Tag(String name) {
           this.name = name;
       }
   }

   @Entity
   public class Post {

       @Id @GeneratedValue
       private Long id;

       private String title;

       @ElementCollection
       @CollectionTable(name = "post_tags",
                        joinColumns = @JoinColumn(name = "post_id"))
       @Column(name = "tag_name")
       private Set<Tag> tags = new HashSet<>();
   }
   ```

### 🔥 오늘의 도전 과제와 해결 방법

- 프론트/백엔드 저장소 구조, 모노레포 vs 멀티레포 결정

  - 처음엔 프론트와 백엔드를 모노레포로 묶을지 고민했다. 모노레포의 장점(버전 관리 일원화, 단일 워크스페이스)도 있었지만, 대규모 서비스 기준으로 보면 배포 경로, 책임, CI/CD 파이프라인이 달라질 가능성이 높았다. → 프론트/백엔드 레포를 분리하는 멀티레포 구조를 선택

- 도메인 기반 백엔드 패키지 구조 설계
  - 대규모 서비스 기준으로 생각할 때 Controller / Service / Repository 를 도메인 단위로 묶는 것이 유지보수성에서 유리해보였다. → member, post, file 등 도메인별 패키지 하위에 controller, service, repository, dto, entity 를 모두 포함하는 구조로 정리

### 🗨️ 오늘의 회고

- '커뮤니티 서비스'라는 개인 프로젝트를 대규모 서비스 기준으로 어떻게 설계할 것인가를 본격적으로 고민한 하루였다. 처음에는 단순히 "일단 기능부터 만들자"라는 생각이었는데, 구조·환경·DDL·패키징 같은 기반이 흔들리면 나중에 더 문제가 생길 것 같았다.
- 프론트/백 분리를 결정하고, DDL/엔티티 매핑을 구성하고, 환경별 YML과 환경변수 전략을 잡으면서 운영 환경을 고려한 설계가 왜 중요한지 깨달았다. 지금은 단순한 개인 프로젝트지만,
  “언젠가 이 프로젝트가 수십만 MAU 서비스라고 생각하고 설계하자” 라는 기준을 세운 것이 앞으로의 개발에도 큰 방향성이 될 것 같다.
