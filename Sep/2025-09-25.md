## 📆 2025-09-25

### 🔔 스크럼

- 서버캐시, 동시성 제어 강의 복습 및 정리
- 이번 주차 과제 수행

### 🚀 Today I Learned

#### Server Cache

- 웹서버가 데이터를 빠르게 제공하기 위해 사용되는 정보를 임시로 저장하는 장소
- Why? 웹사이트의 속도를 높이고, 서버 부하를 줄여서 더 좋은 사용자 경험을 제공하기 위해
- 종류

  - Local Cache
    <img width="796" height="397" alt="Image" src="https://github.com/user-attachments/assets/0cb17dd8-d845-48b0-967f-e0c3fd598170" />
    - 서버 인스턴스에 독립적으로 존재
    - 장점
      - 데이터 접근 속도 매우 빠름
      - 추가적인 네트워크 지연 없음 → 왜? 서버 내에 존재하는 캐시를 사용하기 때문에 네트워크 통신비용 X
    - 단점
      - 스케일 아웃시(수평확장) 일관성 유지 어려움
    - 작동 방법
      - client 요청 → 서버는 로컬캐시한테 물어봄 → 있으면 client에게 전달, 없으면 DB조회해서 전달
    - ex) 세션 정보(단일 서버), 임시 계산결과
    - `HashMap`, `ConcurrentHashMap`, `Guava Cache`, `Caffeine`
  - Global Cache
    <img width="805" height="407" alt="Image" src="https://github.com/user-attachments/assets/5d365775-01dd-48f9-ba21-afa6354d7b7a" />

    - 여러 서버 인스턴스간에 공유되는 캐시
    - 장점
      - 데이터 일관성과 공유가 용이
    - 단점
      - 네트워크 지연 가능성
      - 로컬캐시에 비해 상대적으로 느림
    - ex) 세션정보(멀티서버), 인증, 공유설정, 공유
      - 보통 별도 서버(예: **Redis**, **Memcached**, **Aerospike**)에 둠.

    💡 CDN(Content Delivery Network)

    - 전 세계 데이터 센터에 파일 사본을 임시로 저장하는 ‘캐싱’이라는 프로세스를 통해 사용자가 가까운 서버에서 인터넷 콘텐츠에 접속할 수 있게 하는 분산된 **캐싱 프록시 네트워크**
    - 캐싱 프록시 ⇒ 중간에서 요청/응답을 처리하는 서버가 프록시인데, 그 프록시가 캐싱역할까지 하는걸 말함
    - 내가 알고있는 이미지 올리는 CDN이랑 다른건가?
      - 같은것임. 이미지를 네이버클라우드(aws)에 올리면 그거가 원본이고, 올라간 사진의 링크 앞단을 cdn. 어쩌고로 바꿨던이유가 이거였던것!
    - 참고 - https://velog.io/@qotndus43/Cache

#### DB 동시성 제어

- 여러 사용자가 통시에 DB 접근할때 발생하는 문제를 방지하고, 데이터의 일관성, 무결성을 유지하기 위한 기술
  ❓ 일관성
  - DB가 트랜잭션 전후에도 항상 정의된 규칙을 만족하는 상태를 유지하는것
    ❓ 무결성
  - 데이터가 정확하고 신뢰할 수 있는 상태를 유지하는것을 의미
- BUT, 동시성과 일관성은 반비레 관계임 → 이 균형을 맞추기 **동시성 제어 기법**이 나온것
- Conflict(충돌) : 하위 3개 조건이 만족하면 Conflict 발생했다고 함
  - 서로 다른 트랜잭션일것
  - 같은 data에 접근
  - 최소 1개는 write
- Serializability(직렬화) : 여러 트랜잭션이 동시에 실행돼도, **마치 하나씩 차례대로(직렬로) 실행한 것과 같은 결과**가 나오게 하는 것

  💡 충돌났다고 다 직렬화 하는 것은 아님!

  - 수행순서에 따라 결과가 달라지는 경우에 직렬화가 필요한것!

⇒ 정리해보자면, 여러 트랜잭션이 동시에 실행되면 **“충돌”**이 발생할 수 있고, 이 충돌을 어떻게 관리하든 결과는 **“직렬 실행한 것과 같은 상태”**를 보장해야한다. 이를 위해 등장한 기법이 아래 기법들!

- Locking Mechanism(락킹 매커니즘)

  - 비관적 락

    - 충돌 가능성을 가정하고, 데이터 사용전에 락을 걸어버리는 방법
    - 장점 : 높은 무결성, 충돌/데이터 손상 방지, 신뢰성 UP
    - 단점 : 동시성 저하, 데드락 발생가능성, 트랜잭션 대기시간 길어짐
    - ex) 일반적으로 RDBMS에서 사용됨

      ❓ 교착상태(데드락)

      - 2개 이상의 트랜잭션이 락을 서로 걸어놓고 서로의 락을 요구하여 상황이 바뀌지 않는 상태 → 방지 방법 : 트랜잭샨 자주 커밋, 정해진 순서대로 테이블 접근 등

  - 낙관적 락
    - 충돌이 일어나지 X 생각하고, data 먼저 사용한뒤 업데이트시에 충돌 검사하는 방법
    - ex) 주로 NoSQL에서 사용됨
    - 장점 : 높은 동시성, 성능향상, 분산시스템에 적합, 읽는 속도 빠름
    - 단점 : 무결성 수준 낮음, 충돌 발생시 복잡한 예외처리 로직 필요, 버전관리, 추가 구현비용 요구, 충돌 발생시 재시도 비용 증가

💡 **Transaction** vs **Lock**

- 트랜잭션은 **논리적 단위(작업을 묶음)**
- 락은 **물리적 제어(충돌을 막음)**
- 트랜잭션을 안전하게 유지하기 위한 수단 중 하나가 **락** (또는 MVCC 같은 다른 기법)

### 🔥 오늘의 도전 과제와 해결 방법

### 🗨️ 오늘의 회고

-
