## 📆 2025-09-30

### 🔔 스크럼

- 영속성 컨텍스트, 연관관계 매핑 강의 복습 및 정리
- 교재 Git 공부하면서 과제 완료

### 🚀 Today I Learned

#### @Transient

- 해당 필드를 엔티티에는 포함시키지만, 데이터베이스 컬럼으로 매핑하지 않도록 하는 어노
- ex) 내부 로직에만 필요한 값들(표시용 문자열, API응답전용필드, 임시계산결과 보관 등)

#### 영속성 컨텍스트

- **JPA가** 엔티티 객체를 관리하며, 동일 트랜잭션 내에서 변경 사항을 추적하고 자동으로 DB와 동기화하는 **메모리 상의 저장소**
- Why? 잦은 DB접근은 성능저하 유발
- **트랜잭션과 유사한 생명주기로, 같은 트랜잭션 내에서만 동작함**
- **EntityManager를 통해 접근**
- 특징
  1. **1차 캐시** : 영컨 내부에 존재하는 엔티티 저장소, pk를 키로하여 엔티티 인스턴스 보관
     - 엔티티 조회할때 1차 캐시에서 먼저 탐색하고, 없으면 DB조회한 뒤 캐시에 저장
     - 트랜잭션 끝나면 같이 날아감
     - persist()
  2. **쓰기지연** : 쿼리 DB 바로반영 X, 1차캐시에만 반영하고 쿼리는 쓰기지연 저장소에 쌓아둠 → 이후 변경사항은 동기화할때(flush) 한번에 적용됨
     - But, IDENTITY 방식처럼 키를 즉시 확보해야 하는 경우에는 INSERT가 바로 실행
  3. **변경감지** : 로딩 시점의 엔티티 상태를 스냅샷으로 저장해두고, 현재값과 비교하여 변경여부 판별
     - 커밋 시점의 flush단계에서 변경된 필드를 찾아 필요한 update sql 생성하여 쓰기지연저장소에 넣어둠
- 장점 : 위의 특징들 덕분에 아래 장점들이 생긴것 → 즉, 개발자가 쿼리를 짜지 않아도 객체지향적으로 코드를 짤 수 있음
  - **엔티티 관리**
  - **DB접근제한**
- 영컨 내 엔티티는 4가지 상태를가짐
  - Why? 트랜잭션 내에서 객체의 생명주기를 추적하고, 1차 캐시의 무결성과 일관성을 보장하기 위해 필요
  - 아래와 같은 상태들이 있어야 똑같은 쿼리가 조회하러 올떄 아 얘는 삭제될 예정이네?하고 답을 보낼 수 있으니까
  - **비영속** : 객체는 생성되지만 영컨에서 관리하지 X → EntityManager 사용X
  - **영속** : 생성된 객체가 영컨에 등록되어 관리되는 상태 → persist()
  - 준영속 : 영속상태 였으나 영컨에서 (자동,수동)분리된 상태 → detach(), clear(),close()
  - 삭제 : 영컨에서 관리되다가 삭제하기로 표기한 상태 → remove()
- 기본 생성자 필수, final 지양

#### Transaction in JPA

- “엔티티의 상태 변화 → 영속성 컨텍스트에 기록 → 커밋 시 데이터베이스 반영”이라는 과정을 하나로 묶어 처리하는 장치
- `@Transactional`
  - @Transactional(readOnly = true) : 조회 전용 트랜잭션

#### 연관관계 매핑

- 엔티티 객체 간의 관계를 설정하여, 객체지향적으로 연결된 데이터 구조를 정의하고 관리할 수 있도록 해주는 매핑구조

```java
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;
}

@Entity
public class Post {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @ManyToOne
    @JoinColumn(name = "user_id") // 외래 키 매핑
    private User user;
}
```

- 여기서 주인은 Post → 주인? = 외래키 누가관리, 주인은 `@JoinColumn`을 사용
- ex ) `post.getUser().getName()` → DB에서 join의 역할

##### 단방향 연관관계

- 한 엔티티에서만 다른 엔티티를 참조해 관계를 맺는 매핑 방식 → 참조를 가진 쪽에서는 반대편 엔티티에 접근할 수 있지만, 반대편에서는 이 관계 알수X
- Why? 설계 단순화, 불필요한 의존성 down
- 반대 방향 참조 필요하면, **스키마 변경 없이** `mappedBy`를 이용해 읽기 전용 컬렉션을 추가
- 보통 초기에는 단방향, 필요할때만 양방향으로 확장

##### 양방향 연관관계

- 두 엔티티가 서로를 참조해 양쪽에서 모두 관계를 탐색할 수 있도록 매핑한 방식
- **객체 그래프 탐색**만으로도 SQL 조인을 자동으로 수행하여, 관계 데이터 조회가 훨씬 직관적으로 가능

```java
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany(mappedBy = "user") // 외래 키는 Post가 관리
    // 여기서 mappedBy = "user"로 지정해 **이 필드는 외래 키를 관리하지 않음**을 JPA에 알림
    // 읽기전용
    private List<Post> posts = new ArrayList<>();
}

@Entity
public class Post {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @ManyToOne
    @JoinColumn(name = "user_id") // post.user_id → user.id
    private User user;

    // 연관관계 편의 메서드
    public void setUser(User user) {
        this.user = user;
        user.getPosts().add(this);  // 양방향 동기화
    }
}
```

##### ManyToOne, OneToMany, OneToOne(잘사용X), ManyToMany(잘사용X)

##### 상속관계 매핑

- 객체의 상속 구조를 테이블 구조에 맞게 매핑해 부모와 자식 엔티티를 저장·조회할 수 있도록 하는 기능
- 관계형 데이터베이스에는 상속 개념이 존재X, JPA는 슈퍼타입–서브타입 모델로 상속 관계를 표현

#### Proxy

- JPA에서 지연 로딩을 사용할 때 실제 엔티티 대신 먼저 생성되어, 데이터가 필요한 순간에 실제 조회를 지연시키는 가짜 객체
  - 지연 로딩(LAZY) : **실제로 해당 연관 데이터를 사용할 때** 데이터베이스에서 조회하는 방식 → 불필요한 SQL실행이 줄어듬. but, 연관데이터를 사용하는 시점마다 추가 SQL 발생할수있음
  - 즉시 로딩(EAGER) : 엔티티를 조회하는 시점에 연관된 데이터까지 한 번에 불러오는 방식→ 한 번의 조회로 연관 데이터까지 모두 로드하므로 이후 접근 시 추가 SQL없음. but, 불필요한 부하발생 & JPQL 사용 시 **N+1 문제**가 발생할 가능성
  - `@ManyToOne`, `@OneToOne` 기본값 : **EAGER → LAZY 변경 권장**
  - `@OneToMany`, `@ManyToMany` 기본값 : **LAZY**
- Why? 연관된 엔티티를 실제로 사용할 때까지 조회를 미뤄, 초기 쿼리 수를 줄이고 성능을 최적화하기 위해
- 프록시는 반드시 트랜잭션 범위 안에서 초기화 되도록 관리해야함.

```java
@Entity
@Getter @Setter
public class Post {

    @Id @GeneratedValue
    @Column(name = "post_id")
    private Long id;

    private String title;
    private String content;

    @Enumerated(EnumType.STRING)
    private PostType postType;

		// manytoone은 기본전략이 EAGER(즉시)라서 지연로딩으로 바꿔줌
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id") // FK(post.user_id) → user.user_id
    private User author;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private LocalDateTime deletedAt;

    public Post() {}

    public Post(String title, String content, PostType postType, User author) {
        this.title = title;
        this.content = content;
        this.postType = postType;
        this.author = author;
    }
}
```

### 🗨️ 오늘의 회고

- 확실히 이론만으로는 손에 잘 잡히지 않는 부분이 많다는 걸 다시 느꼈다. 영속성 컨텍스트나 연관관계 매핑처럼 개념은 분명한데, 실제 코드 흐름 속에서 어떤 의미로 작동하는지 이해하려면 직접 구현해보는 과정이 꼭 필요함을 느꼈다. 앞으로 개인 프로젝트에 적용하면서 “아 이게 그때 배운 그 개념이구나” 하고 더 깊게 연결될 것 같다.
