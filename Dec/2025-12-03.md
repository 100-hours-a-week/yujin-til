## 📆 2025-12-03

### 🔔 스크럼

- Controller 심화학습, 스케줄링과 오토스케일링 강의 복습 및 정리
- 이미지 업로드 및 기타 수정 사항 서버 배포 후 기능 점검

### 🚀 Today I Learned

### Controller

- 클러스터의 현재 상태를 지속적으로 모니터링하고, 사용자가 정의한 목표 상태와 일치하도록 조치를 취하는 자동화된 관리 루프
  - 비유 : 에어컨
- 사용이유
  - 클러스터 내에서 리소스 자동 관리
  - 안정적으로 운영 가능
  - 운영 효율성 높아짐
  - 확장성, 유연성
- Deployment : 웹서비스, 웹 애플리케이션 배포할 때 많이 사용
- StatefulSet : 보통 DB배포할때 많이 사용
- DaemonSet : 특정 노드에 항상 실행되는게 있을때
- Job : 1회성으로 뭔가를 처리해야할때
- CronJob : 주기적으로 뭔가를 처리해야할때

#### ReplicaSet

- 특정 수의 Pod 복제본을 항상 유지하는 데 사용되는 컨트롤러
- 설정된 복제 수 정하면 현재상태와 비교해서 추가/삭제
- 클러스터 내의 수많은 파드들 중에서 관리할 파드를 찾기위해 label-selector 사용
- Replica가 지켜야할 복제본이 몇개? → replicas : 5
- 파드를 관리한다
  - 파드가 많아지면 삭제할 수 있다
  - 파드가 적으면 생성
  - ⇒ pod tempalte에 정의해둠
- 주요역할, 동작 방식
- 사용이유 : 애플리케이션의 안정성과 가용성 보장 & 서비스 중단없이 클러스터 관리

##### Stateless Application

- WS, WAS ← Http사용하니까(stateless)
- 특징
  - 애플리케이션 여러 파드가 만들어져도 각각이 동일한 역할 수행
  - 볼륨 필요 → 기록이 필요 없음
  - 트래픽 분산
- 이럴때 ReplicaSet 컨트롤러 사용

##### Stateful Application

- 데이터베이스
- 특징
  - 파드별로 역할이 지정되어있는 경우가 많음
    - ex) RDB : master는 쓰기만, slave는 읽기만
  - 파드를 개별적으로 “인식”
    - 이름이 규칙성을 띔 → StatefulSet -파드숫자
  - 파드별로 볼륨 할당 받은걸 고유하게 사용함
  - 볼륨은 파드가 날아가도 유지된다.
- 이때 StatefulSet Controller 사용함

#### Deployment

- 쿠버네티스에서 Pod, Replicaset을 관리
  - 왜? 애플리케이션 배포, 업데이트, 확장, 복구를 자동으로 수행하는 컨트롤러라
- 디플로이먼트, 레플리카셋은 포함관계
  - 디플로이먼트가 업데이트할때, 새로운 레플리카셋 생성
  - 기존 레플리카셋은 일단 유지 ← 롤백하기 쉽게
  - 디플로이먼트가 하는일
    - 레플리카셋 조율(수명주기 제어)
- 사용이유 : 애플리케이션 배포, 업데이트, 복구를 자동화하기 위해
  - 서비스 안정성 + 운영 효율성
- 주요 역할
  - 파드, 레플리카셋 관리
    - 파드를 직접관리하느것은 아님
    - 파드는 레플리카셋을 관리
    - 레플리카셋을 디플로이먼트가 관리
    - 새로운 배포시에 새로운 레플리카셋을 만듬
- 무중단 배포
  - 롤링 배포 ← 기본 전략
  - 이전 버전 복구
- Recreate 배포
  1. 기존 파드 돌고있음
  2. 기존 파드 삭제
  3. 신규 파드 만들고
  4. 신규 파드 활성화
  - 블루그린이랑 비슷함. 근데 순서가 다름
  - Recreate 활용예시
    - 잘사용안하긴함
    - 테스트 환경 배포
    - 데이터베이스 의존성이 강한 애플리케이션
      - v1 ← DB 스키마가 name + email
      - 2 ← DB 스키마 완전 달라짐
      - v1-v2 호환성 매우 약함
      - 따라서, 동시 진행 불가해서 recreate로 배포
- Rolling Update
  - 기존 파드-새로운 파드를 순차적 교체
  - 서비스 중단 없이 할때 배포하는 방식
  - 활용사례
    - 프로덕션
    - 업데이트 점진적
    - 대규모 배포 환경

#### Statefulset

- 쿠버네티스가 상태를 가진 애플리케이션 배포, 관리하는 컨트롤러
- 주요 특징
  - 네트워크 ID가 고유해야함
    - 상태를 저장하는 애들은 보통 역할이 지정되어있음
    - 해당 파드를 찾아갈수있어여함
  - 영구 스토리지 유지
  - 파드 생성 시 순서 중요
  - Headless와 같이 씀
- ReplicaSet vs StatefulSet

#### Job

- Job : (대규모) 일회성 작업을 실행, 관리하는 컨트롤러
  - 데이터 처리, 일회성 배치 처리
  - 데이터베이스를 마이그레이션
- 주요 특징
  - 작업 완료 보장
    - 1회성 작업
    - 정상처리되었다는 확정이 필요
    - ex ) 프로세스 1개로 DB전체 옮기는것 어렵다
      - 도중에 실패하면 안되고, 다시 재시도 해야함
        - 근데, 실패할 가능성 높음
      - 우리 작업이 성공는데 필요한 성공한 파드의 개수 설정
        - completions : 3
        - 작업을 3개의 파트로 시작 ← 각각 모두 완료해야 성공한거라고 판정지을수 있음
  - 병렬 처리 지원
    - 1회성을 보통 대규모 작업이라 병렬처리 지원
    - 처리 속도 up
      - completions ← 작업 성공해야하는 양
      - parallelism ← 동시에 실행할 수 있는 파드의 최대 수
    - 끝나면 자동 종료

#### CronJob

- Cron : Unix/Linux 환경에서 사용되는 시간 기반 작업 스케줄러
- 정기적으로 데이터 백업, 로그정리, 보고서, 사용자 통계
  - 사용자 통계를 만들때도 자주 사용함
  - 고아 이미지 처리
  - 썸네일 처리
- 주요 특징
  - 정리적으로 특정 작업 수행
  - 작업내역을 남긴다
  - 실행 보장
- 구성요소
  - 스케줄 표현식
  - Job 템플릿
  - 성공/실패 기록 제한
  - 동시 실행 정책

#### 크론 유의사항

1. 로컬에서 먼저 돌려야한다.
   1. 코드 검증 필수
   2. 좀비 잡 ← 코드 버그 혹은 무한 루프에 빠질 수 있음
2. 무한 재시도 방지
   1. 잡은 성공 하려고한다 ← limit없으면 계속 재시도함. 자원 많이먹음
3. 타임존 문제
   1. 쿠퍼네티스의 컨트롤러는 UTC기준 작업
4. 크론잡 중목 실행
   1. 짧은 주기로 설정햐여야하는 경우
5. 기록 청소
   1. 크론잡 실행되면 흔적이 남음(Completed ← 파드 리스트)
   2. 디스크 먹음
   3. 제한 걸어줘야 한다
      1. 성공기록 → 5개
      2. 실패기록 → 10-20개

### Node Scheduling

- 클러스터 내의 다양한 노드 중에서 Pod를 실행할 적절한 노드를 선택하고 할당하는 프로세스
- 주요 구성 요소
  1. 기본 스케줄링 : 별도의 설정없이 쿠버네티스가 상태에 따라 자동으로 노드 선택
  2. NodeName (많이 사용안함) : 특정 Pod를 고정된 노드에 할당
  3. NodeSelector (많이 사용안함) : 특정 라벨을 가진 노드에
  4. **NodeAffinity**
     - 라벨을 조건식으로 걸어서 복잡하게 사용하는 고급 스케줄링 방식
     - **`Required~` :** 조건을 반드시 만족해야 스케줄링됨
     - **`Preferred~` :** 조건을 만족하면 우선배치지만 필수는 아님
  5. Taint와 Toleration
     1. NodeSelector 및 NodeAffinity와 함께 노드 기반의 스케줄링 제약 조건을 정의
     2. 특정 노드에 Pod가 배치되지 않도록 제한하거나, 특정 조건을 만족하는 Pod만 배치될 수 있도록 허용하는 방식으로 작동

### AutoScaler - HPA

- 리소스 사용량이나 사용자 정의 메트릭을 기반으로 Pod의 개수를 자동으로 조정하여 애플리케이션의 처리 능력을 관리하는 컨트롤러
- deployment랑 짝꿍을 이루는 경우가 많음
- 핵심 구성요소
  - scaleTargetRef : 관리할 대상이 무엇인지 정함
  - **metrics : Pod의 리소스 사용량에 대한 목표치 정의**
  - 리소스 계산 공식 : 공식을 사용하여 Pod수 계산
  - limits, requests : 최소 리소스양, 최대 리소스양

#### 주의 사항

- 콜드 스타트 ← 가장 많이 걸리는 상황
  - 트래픽이 몰려서 파드를 1→5개 늘렸지만, 자바는 30초걸림
    - HPA파드 만들었으니 트래픽이 줄거라고 예상하지만, 부하 안줌
    - HPA의 limit이 100인데, 아직도 트래픽 안줄면 계속 올림
    - 레디니스 프로브 설정 필요
- 깜박임 현상
  - 파드를 늘리고 줄이고함

### AutoScaler - VPA

- Pod의 리소스를 동적으로 조절하는 방식
- 보통 StatefulSet이랑 같이 쓰임
  - RDBMS같은 애들은 인스턴스를 늘리기 함듬
  - 그래서 보통 CPU - RAM - SSD를 늘리려고 함
- 구성요소
  - VPA Recommendation : 권장값 설정
  - VPA Updater : 권장값 반영
    - 파드에 반영하려면, 기존 파드 삭제하고 새롭게 생성한 파드부터 적용할 수 있음
  - Admission Controller : 리소스 초기값 최적화

#### 주의 사항

- DB에 많이 사용
  - 파드 늘리기 힘드니 덩치 키워 처리량 늘림
- 재시작 ← VPA 적용을 위해
  - 적용을 사람이 수동으로하거나
  - Mereics Server에서 HPA+VPA으로 자동적용이 되긴하지만 복잡함
  - 서비스 중단될 가능성 염두
- HPA랑 충돌위험
  - ex ) HPA → 메트릭 : CPU, VPA → 메트릭 : CPU
    - 둘다 같이 쓴다고하면, 파드를 늘리고키우니까 충돌위험이 있음
    - 같이 쓰면 보통 HPA ← 트래픽, VPA ← CPU+Mem
    - 둘이 같은 메트릭만 안보면됨

### AutoScaler - CA

- 클러스터에서 리소스 요구에 따라 자동으로 노드를 추가하거나 삭제하여 클러스터의 크기를 동작으로 관리
- 클라우드 프로바이더와 연동하여 동적 스케일링 수행
- 특징
  - 노드를 제거하기 전, 해당 노드의 파드가 다른 노드로 안전하게 이동할 수 있도록 자동으로 재배치과정 수행
  - 클라우드 프로바이더 통합
  - 최소 및 최대 노드 제한이 되어있어야함
- 주의사항 - 비용 주의!
  - 최대 노드 개수 잘 설정해야함
  - 노드도 콜드스타트 주의

### 🔥 오늘의 도전 과제와 해결 방법

- S3 환경변수가 CI/CD 배포 후 백엔드에서 주입되지 않는 문제

  - S3 관련 환경변수(S3_ACCESS_KEY, S3_SECRET_KEY 등)를 설정했음에도,
    CI/CD를 통해 배포된 서버에서는 Spring이 해당 변수를 읽지 못해 앱이 부팅 실패하는 문제가 발생함.
  - 처음에는 CI/CD YAML에서 git pull이 없어서 compose 파일이 최신 버전이 아니라고 판단해 코드를 추가했지만, 실제로 서버에서 pull을 시도해보니 충돌 오류가 발생하며 pull이 되지 않음을 확인.
  - 원인은 과거에 서버에서 테스트하려고 docker-compose.yml과 application.yml을 직접 수정했어서 git pull이 거부된 것.
  - 서버에서 수정된 파일들을 원복한 뒤 다시 pull하니 최신 compose 파일이 적용되었고, 환경변수도 정상 주입되어 S3 연동 및 백엔드 API 호출 정상화됨.

- 댓글 입력 시 Enter 한 번에 동일 댓글이 여러 개 등록되는 문제
  - 댓글 작성 입력창에서 Enter를 누르면 댓글이 3~4개씩 중복 등록되는 현상이 발생함. 코드 흐름을 추적해본 결과, 댓글 작성 후 리스트를 다시 불러오는 과정에서 initCommentForm(postId)가 UI 리셋 단계마다 반복 호출됨을 발견 → 그 안에서 Enter keydown 이벤트가 계속 다시 등록되고 있었던 것.
  - 해결은 간단하게, initCommentForm() 내부에 초기화 여부 플래그를 두어 딱 한 번만 실행되도록 가드 처리함 → 이후 Enter 입력 시 정상적으로 댓글 등록됨

### 🗨️ 오늘의 회고

- 개인 프로젝트가 막바지에 접어들면서 작은 수정과 서버 테스트할 일들이 많아 정신이 없다. 기능 하나 고치면 다른 부분에서 다시 잡아야 할 게 생기고, 배포하면서 예상 못 한 설정 문제까지 터져서 하루하루가 너무 빨리지나간다. 쿠버네티스 강의 복습도 병행해야 해서, 익숙하지 않은 개념들을 정리하는 데 꽤 시간이 걸린다. 그래도 하나씩 정리하고 해결해 나가면서 조금씩 감이 생기는 것 같고, 끝까지 하다보면 남는게 많이 있을거라는 마음으로 임하고있다.
